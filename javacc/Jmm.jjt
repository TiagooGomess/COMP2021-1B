options
{
    LOOKAHEAD=1;
    /* FORCE_LA_CHECK=true; */
}

PARSER_BEGIN(Jmm)

// import pt.up.fe.specs.util.SpecsIo;

import java.io.InputStream;
import java.io.ByteArrayInputStream;

public class Jmm
{
    public static void main(String args[]) throws ParseException {
      System.out.println("Compiling the code...\n\n");
      // InputStream jmmStream = new ByteArrayInputStream(SpecsIo.getResource("fixtures/public/HelloWorld.jmm").getBytes());
      Jmm myJmmCode = new Jmm(System.in);
		SimpleNode root = myJmmCode.parser(); // returns reference to root node
        	
		root.dump(""); // prints the tree on the screen

		//System.out.println("Expression value: "+myCalc.eval(root));
    }
	
}

PARSER_END(Jmm)

SKIP :
{
   // Whitespace
	" " |
   "\r" |
   "\t" |
   "\n" | 

   // Comments (VER COM O PROF)
   < "//"(~["\n","\r"])*["\n","\r"]> |
   < "/*" (~[])* "*/" >
}

TOKEN:
{   
   // Literals
   < INTEGER_LITERAL:  ["1"-"9"](["0"-"9"])* > |
   < BOOLEAN_LITERAL: "true"|"false" > |
   
   // Punctuation
   < SEMICOLON: ";" > |
   < OPEN_BRACES: "{" > |
   < CLOSE_BRACES: "}" > |
   < OPEN_PARENTHESIS: "(" > |
   < CLOSE_PARENTHESIS: ")" > |
   < OPEN_BRACKETS: "[" > |
   < CLOSE_BRACKETS: "]" > |
   < COMMA : "," > |
   < DOT : "."> |

   // Import
   < IMPORT: "import" > |
   
   // Class Declaration
   < CLASS: "class" > |
   < EXTENDS: "extends" > |
   
   // Methods and attributes
   < PUBLIC: "public" > |
   < STATIC: "static"> |
   < VOID: "void" > | 
   < MAIN: "main" > |
   < STRING: "String" > |
   < RETURN: "return" > |
   < LENGTH: "length" > |
   < NEW: "new" > |
   < THIS: "this" > |

   // Types
   < INT: "int" > |
   < BOOL: "boolean"> |
      
   // Logical Operators
   < NOT: "!" > |
   < AND: "&&" > |
   < LT: "<" > |

   // Arithmetic Operators
   < PLUS: "+" > |
   < MINUS: "-" > |
   < MULT: "*" > |
   < DIV: "/" > |

   // Attribution Operator
   < EQUAL: "=" > |
   
   // Decision
   < IF: "if" > |
   < ELSE: "else" > |

   // Loop
   < WHILE: "while" > |

   // Identifier   
   < IDENTIFIER: (["a"-"z","A"-"Z","_"](["a"-"z","A"-"Z","0"-"9","_"])*) >
}

SimpleNode parser(): {}
{
   ImportDeclaration() ClassDeclaration() <EOF> {return jjtThis;} 
}

void ImportDeclaration(): {}
{
   (<IMPORT> <IDENTIFIER> (<DOT> <IDENTIFIER>)* <SEMICOLON>)*
}

void ClassDeclaration(): {}
{
   // Name
   <CLASS> <IDENTIFIER> (<EXTENDS> <IDENTIFIER>)? 
   // Implementation
   <OPEN_BRACES> (VarDeclaration())* (MethodDeclaration())* <CLOSE_BRACES>
}

void VarDeclaration(): {}
{
   Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDeclaration(): {}
{
   // Name
   <PUBLIC> (
   (
      Type() <IDENTIFIER> 
      // Arguments
      <OPEN_PARENTHESIS> ( Type() <IDENTIFIER> (<COMMA> Type() <IDENTIFIER>)* )? <CLOSE_PARENTHESIS> 
      // Implementation
      <OPEN_BRACES> (LOOKAHEAD(2) VarDeclaration())* (Statement())* <RETURN> Expression() <SEMICOLON> <CLOSE_BRACES>
   )
   | // Main
   (
      <STATIC> <VOID> <MAIN>
      // Args
      <OPEN_PARENTHESIS> <STRING> <OPEN_BRACKETS> <CLOSE_BRACKETS> <IDENTIFIER> <CLOSE_PARENTHESIS>
      // Implementation without return
      <OPEN_BRACES> (LOOKAHEAD(2) VarDeclaration())* (Statement())* <CLOSE_BRACES>
   ))
   
}

void Type(): {}
{
   <INT> (<OPEN_BRACKETS> <CLOSE_BRACKETS>)?
   | <BOOL>
   | <IDENTIFIER>
}

void Statement(): {}
{
   <OPEN_BRACES> (Statement())* <CLOSE_BRACES>
   | <IF> <OPEN_PARENTHESIS> Expression() <CLOSE_PARENTHESIS> Statement() <ELSE> Statement()
   | <WHILE> <OPEN_PARENTHESIS> Expression() <CLOSE_PARENTHESIS> Statement()
   | LOOKAHEAD(2) Expression() <SEMICOLON>
   | LOOKAHEAD(2) <IDENTIFIER> (<OPEN_BRACKETS> Expression() <CLOSE_BRACKETS>)? <EQUAL> Expression() <SEMICOLON>
}

void Expression(): {}
{
   <INTEGER_LITERAL> (LOOKAHEAD(2) Right())?
   | <BOOLEAN_LITERAL> (LOOKAHEAD(2) Right())?
   | <IDENTIFIER> (LOOKAHEAD(2) Right())?
   | <THIS> (LOOKAHEAD(2) Right())?
   | <NEW> ((<INT> <OPEN_BRACKETS> Expression() <CLOSE_BRACKETS> (LOOKAHEAD(2) Right())?) | (Expression() <OPEN_PARENTHESIS> <CLOSE_PARENTHESIS> (LOOKAHEAD(2) Right())?))
   | <NOT> Expression() (LOOKAHEAD(2) Right())?
   | <OPEN_PARENTHESIS> Expression() <CLOSE_PARENTHESIS> (LOOKAHEAD(2) Right())?
}

void Right() : {}
{
   (<AND> | <LT> | <PLUS> | <MINUS> | <MULT> | <DIV>) Expression() (LOOKAHEAD(2) Right())?
   | <OPEN_BRACKETS> Expression() <CLOSE_BRACKETS> (LOOKAHEAD(2) Right())?
   | <DOT> ((<LENGTH> (LOOKAHEAD(2) Right())?) |  (<IDENTIFIER> <OPEN_PARENTHESIS> (Expression() (<COMMA> Expression())*)? <CLOSE_PARENTHESIS> (LOOKAHEAD(2) Right())?))
}