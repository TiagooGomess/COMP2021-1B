options
{
   LOOKAHEAD = 3;
   // FORCE_LA_CHECK = true;
}

PARSER_BEGIN(ExpressionCompiler)

import java.io.InputStream;
import java.io.ByteArrayInputStream;

import pt.up.fe.comp.jmm.JmmParser;
import pt.up.fe.comp.jmm.JmmParserResult;
import pt.up.fe.comp.jmm.report.Report;
import pt.up.fe.specs.util.SpecsIo;

import java.io.*;

public class ExpressionCompiler
{
   public static void main(String args[]) throws ParseException {
      System.out.println("Compiling the code...\n\n");

      /* InputStream jmmStream = new ByteArrayInputStream(SpecsIo.getResource("public/HelloWorld.jmm").getBytes()); */

      /*FileInputStream file;
		try {
			file = new FileInputStream("test/fixtures/public/" + args[0] + ".jmm");
		} catch (Exception e) {
			System.err.println("File not found");
			return;
		}
        */
        ExpressionCompiler myJmmCode = new ExpressionCompiler(System.in);
		SimpleNode root = myJmmCode.Program(); // returns reference to root node
        	
		root.dump(""); // prints the tree on the screen

   
   }
	
   public static void expect(String message, Exception exception) {
      System.err.println("Expected " + message + ":\n  " + exception.getMessage());
   }
}

PARSER_END(ExpressionCompiler)

SKIP :
{
   // Whitespace
	" "
   | "\r"
   | "\t"
   | "\n"

   // Comments
   | < 
      "//"
      (
         ~["\n","\r"]
      )*
      ["\n","\r"] 
   > | < 
      "/*" 
      (
         (
            ~["*"] 
         ) | (
            ["*"] ~["/"]
         )
      )*
      "*/"
   >
}

TOKEN:
{   
   // Literals
   < INTEGER_LITERAL:  (["1"-"9"](["0"-"9"])* | "0") >
   | < BOOLEAN_LITERAL: "true"|"false" >
   
   // Punctuation
   | < SEMICOLON: ";" >
   | < OPEN_BRACES: "{" >
   | < CLOSE_BRACES: "}" >
   | < OPEN_PARENTHESIS: "(" >
   | < CLOSE_PARENTHESIS: ")" >
   | < OPEN_BRACKETS: "[" >
   | < CLOSE_BRACKETS: "]" >
   | < COMMA : "," >
   | < DOT : ".">

   // Import
   | < IMPORT: "import" >
   
   // Class Declaration
   | < CLASS: "class" >
   | < EXTENDS: "extends" >
   
   // Methods and attributes
   | < PUBLIC: "public" >
   | < STATIC: "static">
   | < VOID: "void" >
   | < MAIN: "main" >
   | < STRING: "String" >
   | < RETURN: "return" >
   | < LENGTH: "length" >
   | < NEW: "new" >
   | < THIS: "this" >

   // Types
   | < INT: "int" >
   | < BOOLEAN: "boolean">
      
   // Logical Operators
   | < NOT: "!" >
   | < AND: "&&" >
   | < LT: "<" >

   // Arithmetic Operators
   | < PLUS: "+" >
   | < MINUS: "-" >
   | < MULT: "*" >
   | < DIV: "/" >

   // Attribution Operator
   | < EQUAL: "=" >
   
   // Decision
   | < IF: "if" >
   | < ELSE: "else" >

   // Loop
   | < WHILE: "while" >

   // Identifier   
   | < IDENTIFIER: (["a"-"z","A"-"Z","_","$"](["a"-"z","A"-"Z","0"-"9","_","$"])*) >
}

// https://www.cs.purdue.edu/homes/hosking/javacc/doc/errorrecovery.html
JAVACODE

void error_skipto(int kind) {
   ParseException e = generateParseException();  // generate the exception object.
   System.out.println(e.toString());  // print the error message
   Token t;

   while (getToken(1).kind != kind && getToken(1).kind != EOF) {
      t = getNextToken();
   }
}


// ----------------------------------------------------------------
// Program
// ----------------------------------------------------------------

SimpleNode Program() : {}
{
   Expression()
   <EOF>

   {return jjtThis;} 
}

void Expression() : {}
{
   AndExpression()
}

void MethodCall() #void : {}
{
   <IDENTIFIER>
   <OPEN_PARENTHESIS>
   (
      Expression()
      (
         <COMMA>
         Expression()
      )*
   )?
   <CLOSE_PARENTHESIS>
}


void ArrayPosition() #void : {}
{
   <OPEN_BRACKETS>
   Expression()
   <CLOSE_BRACKETS>
}

void TerminalExpression() : {}
{
   (
      <INTEGER_LITERAL>
   ) | (
      <BOOLEAN_LITERAL>
   ) | (
      <THIS>
   ) | (
      <NEW>
      (
         (
            <INT>
            ArrayPosition()
         ) | (
            <IDENTIFIER>
            <OPEN_PARENTHESIS>
            <CLOSE_PARENTHESIS>
         )
      )
   ) | (
      <IDENTIFIER>
   )
}

void ParenthesisExpression() : {}
{
   TerminalExpression()
   | <OPEN_PARENTHESIS> Expression() <CLOSE_PARENTHESIS>
}

void ClassMemberExpression() : {}
{
   ParenthesisExpression()
   (
      (
         <DOT>
         (
            (
               <LENGTH>
            ) | (
               MethodCall()
            )*
         )
      ) | (
         <OPEN_BRACKETS>
         Expression()
         <CLOSE_BRACKETS>
      )
   )?
}

void NotExpression() : {}
{
   ClassMemberExpression()
   | (
      <NOT>
      NotExpression()
   )
}

void MultDivExpression() : {}
{
   NotExpression()
   (
      (
         <MULT>
         | <DIV>
      )
      MultDivExpression()
   )?
}

void AddSubExpression() : {}
{
   MultDivExpression()
   (
      (
         <PLUS>
         | <MINUS>
      )
      AddSubExpression()
   )?
}

void ComparisonExpression() : {}
{
   AddSubExpression()
   (
      <LT>
      ComparisonExpression()
   )?
}

void AndExpression() : {}
{
   ComparisonExpression()
   (
      <AND>
      AndExpression()
   )?
}

/* {
   new identifier(),
   new int identifier[Expression()],
   this,
   identifier,
   BOOLEAN_LITERAL,
   INTEGER_LITERAL
   Expression.length
   Expression[Expression]
   Expression.identifier(...)
}
{(a)}
{!a}
{a * b, a / b}
{a + b, a - b}
{a < b}
{a && b} */