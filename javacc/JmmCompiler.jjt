options
{
   LOOKAHEAD = 1;
   FORCE_LA_CHECK = true;
}

PARSER_BEGIN(JmmCompiler)

import pt.up.fe.comp.jmm.JmmParser;
import pt.up.fe.comp.jmm.JmmParserResult;

import pt.up.fe.comp.jmm.report.*;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

import java.io.*;

public class JmmCompiler
{
   List<Report> reports = new ArrayList<Report>();
   int parenthesisDepth = 0;

   public List<Report> getReports() {
      return this.reports;
   }

   public void addReport(Exception e, String message){
      reports.add(new Report(ReportType.ERROR, Stage.SYNTATIC, e.getStackTrace()[0].getLineNumber(), message));
   }
}


PARSER_END(JmmCompiler)

SKIP :
{
   // Whitespace
	" "
   | "\r"
   | "\t"
   | "\n"

   // Comments
   | < 
      "//"
      (
         ~["\n","\r"]
      )*
      ["\n","\r"] 
   > | < 
      "/*" 
      (
         (
            ~["*"] 
         ) | (
            ["*"] ~["/"]
         )
      )*
      "*/"
   >
}

TOKEN:
{   
   // Literals
   < INTEGER_LITERAL:  (["1"-"9"](["0"-"9"])* | "0") >
   | < BOOLEAN_LITERAL: "true"|"false" >
   
   // Punctuation
   | < SEMICOLON: ";" >
   | < OPEN_BRACES: "{" >
   | < CLOSE_BRACES: "}" >
   | < OPEN_PARENTHESIS: "(" >
   | < CLOSE_PARENTHESIS: ")" >
   | < OPEN_BRACKETS: "[" >
   | < CLOSE_BRACKETS: "]" >
   | < COMMA : "," >
   | < DOT : ".">

   // Import
   | < IMPORT: "import" >
   
   // Class Declaration
   | < CLASS: "class" >
   | < EXTENDS: "extends" >
   
   // Methods and attributes
   | < PUBLIC: "public" >
   | < STATIC: "static">
   | < VOID: "void" >
   | < MAIN: "main" >
   | < STRING: "String" >
   | < RETURN: "return" >
   | < LENGTH: "length" >
   | < NEW: "new" >
   | < THIS: "this" >

   // Types
   | < INT: "int" >
   | < BOOLEAN: "boolean">
      
   // Logical Operators
   | < NOT: "!" >
   | < AND: "&&" >
   | < LT: "<" >

   // Arithmetic Operators
   | < PLUS: "+" >
   | < MINUS: "-" >
   | < MULT: "*" >
   | < DIV: "/" >

   // Attribution Operator
   | < EQUAL: "=" >
   
   // Decision
   | < IF: "if" >
   | < ELSE: "else" >

   // Loop
   | < WHILE: "while" >

   // Identifier   
   | < IDENTIFIER: (["a"-"z","A"-"Z","_","$"](["a"-"z","A"-"Z","0"-"9","_","$"])*) >
}

// https://www.cs.purdue.edu/homes/hosking/javacc/doc/errorrecovery.html
JAVACODE

void skipParenthesis() {
   ParseException e = generateParseException();  // generate the exception object.
   System.out.println(e.toString());  // print the error message
   Token t;
   boolean end = false;

   while(this.parenthesisDepth != 0) {
      t = getToken(1);
      System.out.println(t.image);
      switch (t.kind) {
         case OPEN_PARENTHESIS:
            this.parenthesisDepth++;
            break;
         case CLOSE_PARENTHESIS:
            this.parenthesisDepth--;
            break;
         case EOF:
            return;
         case OPEN_BRACES:
            this.parenthesisDepth = 0;
            return;
         default:
            break;
      }
      getNextToken();
   }
}

// ----------------------------------------------------------------
// Program
// ----------------------------------------------------------------

SimpleNode Program() : {}
{
   try {
      (
         ImportDeclaration()
      )*
      ClassDeclaration()

      <EOF>
   } catch(Exception e){
      System.err.println(e.getMessage());
      addReport(e, e.getMessage());
   }

   {return jjtThis;} 
}

// ----------------------------------------------------------------
// Import
// ----------------------------------------------------------------

void ImportDeclaration() : {String name; String imports;}
{
   <IMPORT>

   name = ImportName()
   (
      <DOT>
      imports = ImportName()
      {name += "." + imports;}
   )*

   <SEMICOLON>

   {jjtThis.put("name", name);}
}

String ImportName() #void : {Token name;}
{
   name = <IDENTIFIER>

   {return name.image;}
}

// ----------------------------------------------------------------
// Class
// ----------------------------------------------------------------

void ClassDeclaration() : {String className; String extendsName = null;}
{
   <CLASS>

   className = ClassName()
   
   (
      extendsName = Extends()
   )?

   <OPEN_BRACES>

   (
      VariableDeclaration()
   )*
   (
      MethodDeclaration()
   )*

   <CLOSE_BRACES>

   {
      jjtThis.put("name", className);
      if(extendsName != null)
         jjtThis.put("extends", extendsName);
   }
}

String ClassName() #void : {Token name;}
{
   name = <IDENTIFIER>

   {return name.image;}
}

String Extends() #void : {String name;}
{
   <EXTENDS>
   name = ClassName()
   {return name;}
}

// ----------------------------------------------------------------
// Variables
// ----------------------------------------------------------------

void VariableDeclaration() #void : {}
{
   (
      VariableDeclarationWithoutIdentifier()
   ) | (
      VariableDeclarationWithIdentifier()
   )
}

void VariableDeclarationWithoutIdentifier() #void : {String type; String name;}
{
   type =  TypeWithoutIdentifier()
   name = VariableName()
   <SEMICOLON>
   VarDeclaration("type", name)
}

void VariableDeclarationAfterIdentifier(String type) #void : {String name;}
{
   name = VariableName()
   <SEMICOLON>
   VarDeclaration(type, name)
}

void VariableDeclarationWithIdentifier() #void : {String type;}
{
   type = VariableType()
   VariableDeclarationAfterIdentifier(type)
}

String VariableType() #void : {Token type;}
{
   type = <IDENTIFIER>

   {return type.image;}
}

String VariableName() #void : {Token name;}
{
   name = <IDENTIFIER>

   {return name.image;}
}

void VarDeclaration(String type, String name) : {}
{
   {
      jjtThis.put("type", type);
      jjtThis.put("name", name);
   }
}

// ----------------------------------------------------------------
// Method
// ----------------------------------------------------------------

void MethodDeclaration() : {String visibility; boolean isStatic = false; String methodName; String type; List<Map<String, String>> arguments = new ArrayList<Map<String, String>>(); Map<String, String> argument;}
{
   visibility = MethodVisibility()
   (
      (
         type = Type()
         methodName = MethodName()
         MethodOpenParenthesis()
         (
            argument = MethodArgument()
            {
               arguments.add(argument);
            }
            (
               <COMMA>
               argument = MethodArgument()
               {
                  arguments.add(argument);
               }
            )*
         )?
         MethodCloseParenthesis()
         MethodImplementation()
      ) | (
         <STATIC>
         {
            isStatic = true;
         }
         type = Void()
         methodName = Main()
         MethodOpenParenthesis()
         MainArgument()
         MethodCloseParenthesis()
         MainImplementation()
      )
   )

   {
      jjtThis.put("name", methodName);
      jjtThis.put("visibility", visibility);
      jjtThis.put("isStatic", isStatic ? "true" : "false");
      jjtThis.put("type", type);
      if(!arguments.isEmpty())
         Arguments(arguments);
   }
}

void Argument(Map<String, String> argument) : {}
{
   {
      jjtThis.put("name", argument.get("name"));
      jjtThis.put("type", argument.get("type"));
   }
} 

void Arguments(List<Map<String, String>> arguments) : {} 
{
   {
      for (int i = 0; i < arguments.size(); i++) {
         Argument(arguments.get(i));
      }
   }
}

void MainArgument() #void : {Token t; Token n;}
{
   t = <STRING>
   ArrayVariableBrackets()
   n = <IDENTIFIER>

   {
      Map<String, String> argument = new HashMap<String, String>();
      argument.put("type", t.image + "[]");
      argument.put("name", n.image);
      List<Map<String, String>> l = new ArrayList<Map<String, String>>();
      l.add(argument);
      Arguments(l);
   }
}

void Return() : {}
{
   <RETURN>
   Expression()
   <SEMICOLON>
}

String Void() #void : {Token v;}
{
   v = <VOID>
   {return v.image;}
}

String Main() #void : {Token m;}
{
   m = <MAIN>
   {return m.image;}
}

String MethodVisibility() #void : {Token v;}
{
   v = <PUBLIC>
   {return v.image;}
}

String MethodName() #void : {Token name;}
{
   name = <IDENTIFIER>
   {return name.image;}
}

void MethodOpenParenthesis() #void : {}
{
   <OPEN_PARENTHESIS>
   {this.parenthesisDepth++;}
}

void MethodCloseParenthesis() #void : {}
{
   <CLOSE_PARENTHESIS>
   {this.parenthesisDepth--;}
}

void MethodImplementation() #void : {}
{
   <OPEN_BRACES>
   (MethodBody())?
   Return()
   <CLOSE_BRACES>
}

void MainImplementation() #void : {}
{
   <OPEN_BRACES>
   (MethodBody())?
   <CLOSE_BRACES>
}

void MethodBody() #void : {Token identifier;}
{
   (
      identifier = <IDENTIFIER>
      (
         (
            VariableDeclarationAfterIdentifier(identifier.image)
            MethodBody()
         ) | (
            StatementAfterIdentifier(identifier.image)
            MethodStatements()
         )
      )
   ) | (
      (
         VariableDeclarationWithoutIdentifier()
         MethodBody()
      ) | (
         StatementWithoutIdentifier()
         MethodStatements()
      )
   )
}

void MethodStatements() #void : {} 
{
   (
      Statement()
   )*
}

Map<String, String> MethodArgument() #void : {String t; String n;}
{
   t = Type()
   n = MethodArgumentName()

   {
      Map<String, String> m = new HashMap<String, String>();
      m.put("type", t);
      m.put("name", n);
      return m;
   }
}

String MethodArgumentName() #void : {Token i;}
{
   i = <IDENTIFIER>
   {
      return i.image;
   }
}

// ----------------------------------------------------------------
// Type
// ----------------------------------------------------------------

String Type() #void : {String type;}
{  
   ( 
      (
         type = TypeWithoutIdentifier()
      ) | (
         type = TypeIdentifier()
      )
   )

   {return type;}
}

String TypeIdentifier() #void : {Token t;}
{
   t = <IDENTIFIER>

   {return t.image;}
}

String TypeWithoutIdentifier() #void : {Token type; boolean isArray = false;}
{
   (
      (
         type = <INT>
         (
            ArrayVariableBrackets()
            {
               isArray = true;
            }
         )?
      ) | (
         type = <BOOLEAN>
      ) | (
         type = <STRING>
      )
   )
   
   {return type.image + (isArray ? "[]" : "");}
}

void ArrayVariableBrackets() #void : {}
{
   <OPEN_BRACKETS>
   <CLOSE_BRACKETS>
}

// ----------------------------------------------------------------
// Statement
// ----------------------------------------------------------------

void Statement() #void : {Token identifier;}
{
   (
      (
         StatementWithoutIdentifier()
      ) | (
         identifier = <IDENTIFIER>
         StatementAfterIdentifier(identifier.image)
      )
   )

}

void If() : {}
{
   <IF>
   <OPEN_PARENTHESIS>
   {this.parenthesisDepth++;}
   Condition()
   <CLOSE_PARENTHESIS>
   {this.parenthesisDepth--;}
   Then()
   <ELSE>
   Else()
}

void Then() : {} 
{
   Statement()
}

void Else() : {}
{
   Statement()
}

void Condition() : {}
{
   Expression()
}

void Block() : {}
{
   <OPEN_BRACES>
   (
      Statement()
   )*
   <CLOSE_BRACES>
}

void StatementWithoutIdentifier() #void : {}
{
   (
      Block()
   ) | (
      If()
   ) | (
      While()
   ) | (
      ExpressionWithoutIdentifier()
      <SEMICOLON>
   )
}

void While() : {}
{
   <WHILE>
   <OPEN_PARENTHESIS>
   {this.parenthesisDepth++;}
   try {
      Condition()
      <CLOSE_PARENTHESIS>
      {this.parenthesisDepth--;}
   } catch(ParseException e) {
      addReport(e, "Expected valid while expression, ignoring the one provided");
      skipParenthesis();
   }
   Statement()
}

void StatementAfterIdentifier(String identifier) #void : {}
{
   (
      (
         Assignment(identifier)
         <SEMICOLON>
      ) | (
         ArrayPosition()
         (
            <EQUAL>
            Expression()
         )?
         <SEMICOLON>
      ) | (
         ExpressionWithoutArrayPosition(identifier)
         <SEMICOLON>
      )
   )
   
}

void Position(SimpleNode position) : {}
{
   {jjtThis = position;}
}

void Assignment(String variable) : {}
{
   <EQUAL>
   Expression()

   {
      jjtThis.put("variable", variable);
   }
}

// ----------------------------------------------------------------
// Expression
// ----------------------------------------------------------------

void Expression() #void : {Token identifier;}
{
   (
      ExpressionWithoutIdentifier()
   ) | (
      identifier = <IDENTIFIER>
      ExpressionAfterIdentifier(identifier.image)
   )
}

void ExpressionWithoutIdentifier() #void : {}
{
   AndExpressionWithoutIdentifier()
}

void ExpressionAfterIdentifier(String identifier) #void : {}
{
   AndExpressionAfterIdentifier(identifier)
}

void ExpressionWithoutArrayPosition(String identifier) #void : {}
{
   AndExpressionWithoutArrayPosition(identifier)
}

// ----------------------------------------------------------------
// Logical Expressions
// ----------------------------------------------------------------

void AndExpression() #void : {}
{
   ComparisonExpression()
   (
      <AND>
      AndExpression()
      #And(2)
   )?
}

void AndExpressionWithoutIdentifier() #void : {}
{
   ComparisonExpressionWithoutIdentifier()
   (
      <AND>
      AndExpression()
      #And(2)
   )?
}

void AndExpressionAfterIdentifier(String identifier) #void : {}
{
   ComparisonExpressionAfterIdentifier(identifier)
   (
      <AND>
      AndExpression()
      #And(2)
   )?
}

void AndExpressionWithoutArrayPosition(String identifier) #void : {}
{
   ComparisonExpressionWithoutArrayPosition(identifier)
   (
      <AND>
      AndExpression()
      #And(2)
   )?
}

void ComparisonExpression() #void : {}
{
   AddSubExpression()
   (
      <LT>
      ComparisonExpression()
      #LessThan(2)
   )?
}

void ComparisonExpressionWithoutIdentifier() #void : {}
{
   AddSubExpressionWithoutIdentifier()
   (
      <LT>
      ComparisonExpression()
      #LessThan(2)
   )?
}

void ComparisonExpressionAfterIdentifier(String identifier) #void : {}
{
   AddSubExpressionAfterIdentifier(identifier)
   (
      <LT>
      ComparisonExpression()
      #LessThan(2)
   )?
}

void ComparisonExpressionWithoutArrayPosition(String identifier) #void : {}
{
   AddSubExpressionWithoutArrayPosition(identifier)
   (
      <LT>
      ComparisonExpression()
      #LessThan(2)
   )?
}

// ----------------------------------------------------------------
// Arithmetic Expressions
// ----------------------------------------------------------------

void AddSubExpression() #void : {}
{
   MultDivExpression()
   (
      (
         <PLUS>
         AddSubExpression()
         #Addition(2)
      ) | (
         <MINUS>
         AddSubExpression()
         #Subtraction(2)
      )
   )?
}

void AddSubExpressionWithoutIdentifier() #void : {}
{
   MultDivExpressionWithoutIdentifier()
   (
      (
         <PLUS>
         AddSubExpression()
         #Addition(2)
      ) | (
         <MINUS>
         AddSubExpression()
         #Subtraction(2)
      )
   )?
}

void AddSubExpressionAfterIdentifier(String identifier) #void : {}
{
   MultDivExpressionAfterIdentifier(identifier)
   (
      (
         <PLUS>
         AddSubExpression()
         #Addition(2)
      ) | (
         <MINUS>
         AddSubExpression()
         #Subtraction(2)
      )
   )?
}

void AddSubExpressionWithoutArrayPosition(String identifier) #void : {}
{
   MultDivExpressionWithoutArrayPosition(identifier)
   (
      (
         <PLUS>
         AddSubExpression()
         #Addition(2)
      ) | (
         <MINUS>
         AddSubExpression()
         #Subtraction(2)
      )
   )?
}

void MultDivExpression() #void : {}
{
   NotExpression()
   (
      (
         <MULT>
         MultDivExpression()
         #Multiplication(2)
      ) | (
         <DIV>
         MultDivExpression()
         #Division(2)
      )
   )?
}

void MultDivExpressionWithoutIdentifier() #void : {}
{
   NotExpressionWithoutIdentifier()
   (
      (
         <MULT>
         MultDivExpression()
         #Multiplication(2)
      ) | (
         <DIV>
         MultDivExpression()
         #Division(2)
      )
   )?
}

void MultDivExpressionAfterIdentifier(String identifier) #void : {}
{
   NotExpressionAfterIdentifier(identifier)
   (
      (
         <MULT>
         MultDivExpression()
         #Multiplication(2)
      ) | (
         <DIV>
         MultDivExpression()
         #Division(2)
      )
   )?
}

void MultDivExpressionWithoutArrayPosition(String identifier) #void : {}
{
   NotExpressionWithoutArrayPosition(identifier)
   (
      (
         <MULT>
         MultDivExpression()
         #Multiplication(2)
      ) | (
         <DIV>
         MultDivExpression()
         #Division(2)
      )
   )?
}

// ----------------------------------------------------------------
// Not Expressions
// ----------------------------------------------------------------

void NotExpression() #void : {}
{
   ClassMemberExpression()
   | (
      <NOT>
      Negation()
   )
}

void NotExpressionWithoutIdentifier() #void : {}
{
   ClassMemberExpressionWithoutIdentifier()
   | (
      <NOT>
      Negation()
   )
}

void NotExpressionAfterIdentifier(String identifier) #void : {}
{
   ClassMemberExpressionAfterIdentifier(identifier)
}

void NotExpressionWithoutArrayPosition(String identifier) #void : {}
{
   (
      ClassMemberExpressionWithoutArrayPosition(identifier)
   )?
}

void Negation() : {}
{
   NotExpression()
}

// ----------------------------------------------------------------
// Class Member Expressions
// ----------------------------------------------------------------

void ClassMemberExpression() #void : {}
{
   ParenthesisExpression()
   (
      (
         <DOT>
         (
            (
               Length("expression")
            ) | (
               MethodCalls("expression")
            )
         )
      ) | (
         <OPEN_BRACKETS>
         Expression()
         <CLOSE_BRACKETS>
      )
   )?
}

void ClassMemberExpressionWithoutIdentifier() #void : {}
{
   ParenthesisExpressionWithoutIdentifier()
   (
      (
         <DOT>
         (
            (
               Length("expression")
            ) | (
               MethodCalls("expression")
            )
         )
      ) | (
         <OPEN_BRACKETS>
         Expression()
         <CLOSE_BRACKETS>
      )
   )?
}

void ClassMemberExpressionAfterIdentifier(String identifier) #void : {}
{
   (
      (
         ArrayPosition()
      ) | (
         ClassMemberExpressionWithoutArrayPosition(identifier)
      )
   ) | (
      Variable(identifier)
   )
}

void ClassMemberExpressionWithoutArrayPosition(String identifier) #void : {}
{
   <DOT>
   (
      (
         Length(identifier)
      ) | (
         MethodCalls(identifier)
      )
   )
}

void Length(String identifier) : {}
{
   <LENGTH>
   {
      jjtThis.put("variable", identifier);
   }
}

// ----------------------------------------------------------------
// Parenthesis Expressions
// ----------------------------------------------------------------

void ParenthesisExpression() #void : {}
{
   TerminalExpression()
   | (
      <OPEN_PARENTHESIS>
      {this.parenthesisDepth++;}
      Expression()
      <CLOSE_PARENTHESIS>
      {this.parenthesisDepth--;}
   )
}

void ParenthesisExpressionWithoutIdentifier() #void : {}
{
   TerminalExpressionWithoutIdentifier()
   | (
      <OPEN_PARENTHESIS>
      {this.parenthesisDepth++;}
      Expression()
      <CLOSE_PARENTHESIS>
      {this.parenthesisDepth--;}
   )
}

// ----------------------------------------------------------------
// Terminal Expressions
// ----------------------------------------------------------------

void TerminalExpression() #void : {}
{
   (
      (
         TerminalExpressionWithoutIdentifier()
      ) | (
         VariableToRead()
      )
   )
}

void VariableToRead() #void : {Token name;}
{
   name = <IDENTIFIER>
   Variable(name.image)
}

void Variable(String name) : {}
{
   {
      jjtThis.put("name", name);
   }
}

void TerminalExpressionWithoutIdentifier() #void : {}
{
   (
      (
         Integer()
      ) | (
         Boolean()
      ) | (
         This()
      ) | (
         <NEW>
         Construction()
      )
   )
}

void Integer() : {Token value;}
{
   value = <INTEGER_LITERAL>
   {jjtThis.put("value", value.image);}
}

void Boolean() : {Token value;}
{
   value = <BOOLEAN_LITERAL>
   {jjtThis.put("value", value.image);}
}

void This() : {}
{
   <THIS>
}

void Construction() : {Token type; int size = 0; boolean isArray = false;}
{
   (
      (
         type = <INT>
         Size()
         {isArray = true;}
      ) | (
         type = <IDENTIFIER>
         <OPEN_PARENTHESIS>
         <CLOSE_PARENTHESIS>
      )
   )
   {jjtThis.put("type", type.image + (isArray ? "[]" : ""));}
}

void Size() : {}
{
   <OPEN_BRACKETS>
   Expression()
   <CLOSE_BRACKETS>
}

// ----------------------------------------------------------------
// Sub Expressions
// ----------------------------------------------------------------

void MethodCalls(String identifier) #void : {}
{
   MethodCall()
   (
      <DOT>
      MethodCalls(identifier)
      #MethodCalls(2)
   )?
}

void MethodCall() : {Token n;}
{
   n = <IDENTIFIER>
   MethodCallArguments()

   {jjtThis.put("name", n.image);}
}

void MethodCallArguments() : {}
{
   <OPEN_PARENTHESIS>
   {this.parenthesisDepth++;}
   (
      Expression()
      (
         <COMMA>
         Expression()
      )*
   )?
   <CLOSE_PARENTHESIS>
   {this.parenthesisDepth--;}
}

void ArrayPosition() #void : {}
{
   <OPEN_BRACKETS>
   Expression()
   <CLOSE_BRACKETS>
}