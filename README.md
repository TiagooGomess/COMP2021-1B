# Compilers Project

For this project, you need to [install Gradle](https://gradle.org/install/)

## GROUP: 1B

NAME1: Alexandre Almeida de Abreu Filho, NR1: 201800168, GRADE1: 19 , CONTRIBUTION1: 38%

NAME2: João Paulo Nunes, NR2: 201705457, GRADE2: 13, CONTRIBUTION2: 14%

NAME3: Miguel Rodrigues Gomes, NR3: 201605908, GRADE3: 13, CONTRIBUTION3: 14%

NAME4: Tiago Gonçalves Gomes, NR4: 201806658, GRADE4: 19, CONTRIBUTION4: 34%

### GLOBAL Grade of the project: 18

## Compile

To compile the program, run ``gradle build``. This will compile your classes to ``classes/java/main``.

## Test

To test the program, run ``gradle test``. This will execute the build, and run the JUnit tests in the ``test`` folder. If you want to see output printed during the tests, use the flag ``-i`` (i.e., ``gradle test -i``).
You can also see a test report by opening [build/reports/tests/test/index.html](build/reports/tests/test/index.html).

### Run

To run the project, you can use the following command:
```
java -cp "./build/classes/java/main/:./libs/utils.jar:./libs/gson-2.8.2.jar:./libs/ollir.jar" Main <<jmm_file_to_parse>>
```
This will parse the program and put the results in the results folder

## SUMMARY

The goal of this project was to apply the knowledge acquired in the course unit Compilers and build a compiler for programs in java language. 

The compiler prints a tree with all the nodes of the program and their respective children, generates a file with Java Virtual Machine (JVM) instructions accepted by Jasmin and prints the generated code, and builds a symbol table according to the java code.

The main features of the tool we made are:
- Syntactic error controller
- Semantic Analysis
- Expression Analysis
- OLLIR Generation
- Jasmin Generation

## DEALING WITH SYNTACTIC ERRORS

In order to provide meaningful messages to a user, when a syntatic error is found, at compile time, a message is shown, displaying the line and file in which the error occurred, what token the compiler found, and what it was expecting. This process occurs for all of the errors found in the files, which allows for a faster correction and debugging for the user.

## SEMANTIC ANALYSIS

The semantic analysis performed by our tool is comprised of the steps presented in the *PROS*. These, include the following: 
- Handling uninitialized variables
- Disabling the use of fields in static functions
- Verifying if caller of static methods is a class reference
- Method overloading, including parent class
- Verification of method return types
- Expected type's assumption even if not possible in the first usages
- Length can only be used in arrays
- Handling variables with reserved names in jmm and ollir
- Handling not declared variables
- Handling method and variable redefinition
- Handling types that were not imported nor declared

## CODE GENERATION

The code is generated by our tool by translating Java-- code to jasmin instructions. In order to perform this task, our compiler parses the Java-- code, using javaCC; aftwerwards, if errors in the code are found, theses are reported and the execution stops. Otherwise, an AST is constructed, which is used to generate the LLIR code. Using the generated LLIR code, the corresponding JVM code accepted by jasmin is written, which can refer to invocations of functions, arithmetic expressions, conditional instructions, loops and dealing with arrays.

## TASK DISTRIBUTION

The development of this project was performed mainly using the VSCode extension liveshare, and the IntellIJ extension 'Code With Me', which allows several users to work in the same files simultaneously. Therefore, the majority of the work was developed by the four group members, in a voice call. Despite this fact, Alexandre and Tiago worked the hardest and contributed more than the remaining group members.

## PROS

The tool developed for this course managed to achieve the majority of the goals initially provided, with a couple of extra features. Out of all the 12 stages for the development of the compiler, 11 were succesfully developed. Aside from theses, the following extra features were developed: 

- Handling uninitialized variables
- Disabling the use of fields in static functions
- Verifying if caller of static methods is a class reference
- Method overloading, including parent class
- Verification of method return types
- Expected type's assumption even if not possible in the first usages
- Length can only be used in arrays
- Handling variables with reserved names in jmm and ollir
- Handling not declared variables
- Handling method and variable redefinition
- Handling types that were not imported nor declared

## CONS

The code optimization, related to the register allocation (-r option), and the optimizations related to the -o option were not implememented.
